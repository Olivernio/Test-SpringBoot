    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, Object>> handleNotFound(ResourceNotFoundException ex) {
        return buildErrorResponse(HttpStatus.NOT_FOUND, ex.getMessage());
    }

    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<Map<String, Object>> handleValidation(ValidationException ex) {
        return buildErrorResponse(HttpStatus.BAD_REQUEST, ex.getMessage());
    }

    /**
     * Intercepta DataIntegrityViolationException (Hibernate ConstraintViolation a nivel BD)
     * y devuelve un JSON con HTTP 409 Conflict.
     */
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<Map<String, Object>> handleDataIntegrity(DataIntegrityViolationException ex) {
        String userMessage = "Error de integridad de datos.";
        String constraintName = null;

        // Avanzamos hasta la causa ra√≠z:
        Throwable root = ex.getRootCause();
        if (root instanceof ConstraintViolationException) {
            // <--- esta es la clase de Hibernate:
            ConstraintViolationException cve = (ConstraintViolationException) root;
            constraintName = cve.getConstraintName();
            userMessage = interpretConstraint(constraintName);
        } else if (root instanceof SQLException) {
            String sqlState = ((SQLException) root).getSQLState();
            userMessage = "Error de base de datos (SQLState=" + sqlState + ").";
        }

        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", Instant.now());
        body.put("status", HttpStatus.CONFLICT.value());
        body.put("error", HttpStatus.CONFLICT.getReasonPhrase());
        body.put("message", userMessage);
        if (constraintName != null) {
            body.put("constraint", constraintName);
        }
        return new ResponseEntity<>(body, HttpStatus.CONFLICT);
    }